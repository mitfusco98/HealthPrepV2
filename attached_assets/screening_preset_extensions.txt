Goals recap
Let admins “create from types” using screening criteria authored by specific users under their purview.
Group multiple iterations of the same screening type across users/orgs as interoperable variants / protocols.
Introduce a universal screening type naming system with fuzzy detection and explicit synonym groups (e.g., map “bone density” ⇄ “DEXA”).
Manage availability of presets through the root admin dashboard, including linking synonymous types.
1) Data model changes (minimal, additive)
New tables
universal_types
id (uuid)
canonical_name (str, unique) — e.g., “Bone density (DEXA)”
slug (str, unique) — deterministic from canonical_name
status (enum: active, deprecated)
created_by (user_id, nullable); created_at
universal_type_aliases
id (uuid)
universal_type_id (fk → universal_types.id)
alias (str, unique within UT) — e.g., “DEXA”, “Bone density scan”
source (enum: system, org, user) — who added it
confidence (float, 0–1) — for fuzzy suggestions
screening_protocols
Groups related variants that represent the “same” type across users/orgs.
id (uuid)
universal_type_id (fk)
name (str) — often mirror canonical_name
scope (enum: system, org) — who owns the protocol
org_id (nullable) — if scope=org
created_by, created_at
screening_variants
A specific set of criteria created by a user; tied to a protocol.
id (uuid)
protocol_id (fk → screening_protocols.id)
author_user_id (fk → users.id)
org_id (fk → orgs.id)
label (str) — e.g., “MA template v2”, “Endo clinic protocol”
criteria_json (jsonb) — your existing criteria blob
derived_from_variant_id (nullable fk) — provenance
is_published (bool) — available to admins to create presets
created_at, updated_at
type_synonym_groups
Explicit admin-controlled mappings of synonymous labels.
id (uuid)
universal_type_id (fk)
notes (text)
(Associations stored via aliases & below table)
type_label_associations
Connects free-text labels found in the wild to a universal type.
id (uuid)
label (str) — observed label (“bone density testing”, “dxa”)
universal_type_id (fk)
source (enum: system, root_admin, org_admin, user)
created_by, created_at
Your current screening_types (and/or wherever /screening/types criteria live) stays as-is. When a user saves/updates a type, you create/update a screening_variant and link it to a screening_protocol → universal_type.
2) Fuzzy detection + universal naming
Normalization pipeline (lightweight, no heavy deps required)
Lowercase, trim
Replace _ . - / with spaces
Strip stopwords (“test”, “scan”, “screen(ing)” when safe)
Collapse multi-spaces
Apply simple abbreviation expansion map (e.g., “dxa” → “dexa”)
Optional (if you’re okay with a tiny dep): use rapidfuzz for ratio & token_set_ratio > threshold (e.g., 87). If you want zero deps, implement trigram Jaccard with difflib.SequenceMatcher as fallback.
Resolution order
Exact match on universal_types.slug
Alias match in universal_type_aliases.alias
Association match in type_label_associations.label
Fuzzy candidates against (canonical_name + aliases), pick top > threshold
If < threshold → flag “Unresolved” and prompt admin to link or create a new universal type (writes to type_label_associations and optionally universal_type_aliases)
Root admin can:
Promote an association to a first-class alias (moves/duplicates into universal_type_aliases).
Merge universal types (repoint protocols → new UT; mark old as deprecated).
3) Service layer (use cases)
Create a small service module (e.g., services/screening_catalog.py) to centralize logic:
resolve_universal_type(label: str) -> UniversalType | CandidateList
ensure_protocol(universal_type_id, org_id=None, scope='system'|'org') -> Protocol
upsert_variant(protocol_id, author_user_id, org_id, criteria_json, label, derived_from=None) -> Variant
list_variants_by_scope(admin_user, filters: user_id?, org_id?, universal_type?, only_published?)
create_preset_from_variant(variant_id, target_scope, visibility) — feeds /admin/presets
link_labels(universal_type_id, labels: list[str]) — writes to type_label_associations & suggests aliases
This keeps controllers thin and testable.
4) Permissions / “admin purview”
Compute admin scope as:
root admin → all orgs/users
org admin → their org + child orgs
All listing queries for “create from types” must filter screening_variants.org_id IN admin_scope_org_ids OR scope=system.
A user filter (author_user_id) is optional in the UI for recall by author.
5) API & route changes (minimal, additive)
GET /admin/presets/create-from-types
Query params:
org_id?, user_id?, universal_type_id?, q? (free text; goes through fuzzy resolution to pre-filter)
Returns:
universal_types[] (id, canonical_name, aliases[])
protocols[] (id, name, scope, org_id)
variants[] (id, label, author_user_id, org_id, created_at, criteria_summary, is_published)
POST /admin/presets/create-from-variant
Body:
{
  "variant_id": "uuid",
  "preset_name": "string",
  "visibility": "system|org|private",
  "org_id": "uuid|null"
}
POST /admin/universal-types
Create/update canonical names, add aliases.
POST /admin/universal-types/synonyms
Link labels⇄UT or promote associations to aliases.
GET /admin/synonyms
View/edit type_label_associations grouped by universal type.
6) UI behavior
/admin/dashboard/presets & /admin/presets – “Create from types” drawer
Filters: Universal type (autocomplete on canonical & aliases), Author (multi-select), Org (if root), Published only toggle.
Grouped lists:
Level 1: Universal Type (canonical name + chips for aliases)
Level 2: Protocol (System / Org name)
Level 3: Variants (tile list; show author, updated_at, quick diff badge vs protocol “baseline”)
Actions:
“Create Preset” on a variant → opens naming/visibility modal
“Compare” → side-by-side diff of criteria_json vs another variant
“Promote label to alias” (root admin only) directly from search chips
“Link labels” → admin can associate discovered labels to the UT
/screening/types (authoring)
On save:
Run normalization + resolution
Show “We think this belongs to: Bone density (DEXA) [Confirm/Choose]”
Create/Update variant under the resolved protocol
If unresolved, allow “Request new universal type” (queued to root admin review)
7) Variant / protocol semantics
Protocol = bucket for “same purpose” (e.g., Bone density). There can be a system protocol and org-specific protocols if needed (e.g., local policy).
Variant = a concrete, runnable set of criteria made by a user/team.
Add criteria_hash (SHA256) on variants to detect duplicates across users; surface “identical to X” badge.
Diffing:
Store a normalized, sorted criteria object (stable key ordering) to make diffs deterministic.
Provide UI diff on keys: required fields, thresholds, lookback windows, FHIR triggers, etc.
8) Synonyms (“bone density testing” ⇄ “DEXA scan”)
Root admin UI to:
Create / edit Universal Type (“Bone density (DEXA)”)
Manage aliases (first-class, shown in UI)
Manage associations (observed labels; can promote to alias)
During search, show chips: aliases + top associations; selecting any chip filters by the same universal_type_id.
9) Migration plan (safe & incremental)
Backfill UTs
Generate slugs from existing screening_types.name
Seed universal_types for high-volume names (start with your shipped starter set)
Backfill protocols (system scope) per UT.
Backfill variants from each existing user’s /screening/types criteria:
protocol_id = mapped via UT
author_user_id, org_id, criteria_json, label = original name
Compute criteria_hash
Discover labels: insert each observed name into type_label_associations (source=user)
Flip UI to read from variants/protocols; keep legacy reads for a short deprecation window.
Add admin tools to merge UTs and promote associations → aliases.
10) Performance & indexing
Indexes:
universal_types.slug (unique)
universal_type_aliases.universal_type_id, alias
type_label_associations.universal_type_id, label
screening_variants.protocol_id, org_id, author_user_id, is_published, created_at
screening_variants.criteria_hash
Cache (in-process or Redis):
Canonical map {normalized_label → universal_type_id} with alias & association expansion
Bust on updates to UT/aliases/associations
11) Auditing
Log to your existing admin logs:
UT created/merged/renamed
Alias added/removed
Label linked
Variant published/unpublished
Preset created from variant (with variant_id & criteria_hash)
12) Testing checklist
Resolution accuracy: exact, alias, association, fuzzy, unresolved.
Permission gates: root vs org admin visibility.
Preset creation from:
Same org, different user
Different org (root admin only)
Merge UTs: protocols & variants remap cleanly.
Diff view: stable comparisons across equivalent JSON orderings.
No duplicate variants when multiple users author identical criteria (hash check).
13) Small code stubs to anchor the work
Normalizer (Python)
def normalize_label(s: str) -> str:
    s = s.lower().strip()
    for ch in "_-./":
        s = s.replace(ch, " ")
    s = " ".join(s.split())
    expansions = {"dxa": "dexa", "dexascan": "dexa"}
    tokens = [expansions.get(t, t) for t in s.split()]
    return " ".join(tokens)
Resolution flow
def resolve_universal_type(label: str, dao) -> dict:
    n = normalize_label(label)
    # exact slug
    ut = dao.find_ut_by_slug(slugify(n))
    if ut: return {"match": "exact", "ut": ut}

    ut = dao.find_ut_by_alias(n)
    if ut: return {"match": "alias", "ut": ut}

    ut = dao.find_ut_by_association(n)
    if ut: return {"match": "association", "ut": ut}

    # fuzzy (optional rapidfuzz)
    candidates = dao.fuzzy_find_ut(n, limit=5, threshold=87)
    if candidates:
        return {"match": "fuzzy", "candidates": candidates}

    return {"match": "unresolved", "candidates": []}
Creating a variant on save (in your /screening/types save handler)
res = resolve_universal_type(form.name, dao)
ut_id = ensure_ut_selected_by_user_if_needed(res)  # UI confirm for fuzzy/unresolved
protocol = ensure_protocol(ut_id, org_id=current_user.org_id, scope='org')
variant = upsert_variant(
    protocol_id=protocol.id,
    author_user_id=current_user.id,
    org_id=current_user.org_id,
    criteria_json=form.criteria_json,
    label=form.name
)
What you’ll see in the app after implementing
Admins can open “Create from types,” filter by author or org, and pick from neatly grouped Universal Type → Protocol → Variant stacks.
Root admins can enforce that “Bone density testing,” “DEXA,” and “DXA” all land under one universal bucket, making variants reusable across users/orgs.
Your presets stay clean and deduped, because they’re created from variants with provenance and hashes.