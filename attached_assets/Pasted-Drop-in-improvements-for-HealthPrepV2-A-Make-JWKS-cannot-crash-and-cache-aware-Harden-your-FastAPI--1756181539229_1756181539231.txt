Drop-in improvements for HealthPrepV2
A) Make JWKS cannot-crash and cache-aware
Harden your FastAPI route to never 500 even if a secret is missing; set cache headers explicitly.
# app/jwks_service.py
from fastapi import APIRouter, Response
import os, json, base64
from typing import Dict, List
from cryptography.hazmat.primitives import serialization

router = APIRouter()

def b64u(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).decode().rstrip("=")

def to_jwk(pem_text: str, kid: str) -> Dict | None:
    if not pem_text or not pem_text.strip():
        return None
    try:
        key = serialization.load_pem_private_key(pem_text.encode(), password=None)
        pub = key.public_key().public_numbers()
        n = pub.n.to_bytes((pub.n.bit_length()+7)//8, "big")
        e = pub.e.to_bytes((pub.e.bit_length()+7)//8, "big")
        return {"kty":"RSA","use":"sig","alg":"RS256","kid":kid,"n":b64u(n),"e":b64u(e)}
    except Exception as ex:
        print(f"[JWKS] {kid} parse failed: {ex}")
        return None

def collect(prefix: str) -> List[Dict]:
    keys=[]
    for name,val in os.environ.items():
        if name.startswith(prefix):
            kid = name.replace(prefix, "").lstrip("_") or name
            jwk = to_jwk(val, kid)
            if jwk: keys.append(jwk)
    keys.sort(key=lambda k: k["kid"])
    return keys

@router.get("/nonprod/.well-known/jwks.json")
def jwks_np():
    body={"keys": collect("NP_KEY")}
    return Response(json.dumps(body), media_type="application/json",
                    headers={"Cache-Control":"public, max-age=3600"})   # 1h

@router.get("/.well-known/jwks.json")
def jwks_pr():
    body={"keys": collect("P_KEY")}
    return Response(json.dumps(body), media_type="application/json",
                    headers={"Cache-Control":"public, max-age=86400"})  # 24h
Put fastapi, uvicorn, cryptography in requirements.txt.
Run command (Deployment): uvicorn app.main:app --host 0.0.0.0 --port $PORT.
B) Add a static fallback (zero moving parts)
Serve a baked jwks.json from /static so Epic won’t 502 even if crypto/env fails. You can keep it as a safety net.
# app/main.py
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from app.jwks_service import router as jwks_router

app = FastAPI()
app.include_router(jwks_router)
app.mount("/static", StaticFiles(directory="static", html=False), name="static")

@app.get("/")
def health(): return {"ok": True}
Place files so these also work:
static/.well-known/jwks.json
static/nonprod/.well-known/jwks.json
(If your dynamic route ever fails, you can temporarily point Epic to the static URLs.)
C) Deployment sanity for Replit Deployments
Ensure your Deployment has the PEM env vars (separate from editor Secrets!):
NP_KEY_2025_08_A (non-prod PEM)
P_KEY_2025_08_A (prod PEM)
Verify both URLs return HTTP 200 + JSON:
/nonprod/.well-known/jwks.json
/.well-known/jwks.json
Keep this deployment running so Epic can validate anytime (your laptop can sleep).
D) Tiny key-rotation script (adds new key alongside old)
Use it to print the public JWK you’ll add to your JWKS (or static file) while keeping the private key in Secrets/KMS.
# tools/print_public_jwk.py
import json, base64, sys
from cryptography.hazmat.primitives import serialization

def b64u(b): return base64.urlsafe_b64encode(b).decode().rstrip("=")
pem = sys.stdin.read().encode()
kid = sys.argv[1] if len(sys.argv)>1 else "new-key"
key = serialization.load_pem_private_key(pem, password=None)
pub = key.public_key().public_numbers()
print(json.dumps({"kty":"RSA","use":"sig","alg":"RS256","kid":kid,
                  "n": b64u(pub.n.to_bytes((pub.n.bit_length()+7)//8,"big")),
                  "e": b64u(pub.e.to_bytes((pub.e.bit_length()+7)//8,"big"))}))
Usage:
python tools/print_public_jwk.py my_kid < new_private_key.pem
Append the printed JWK to your keys array for overlap, start signing with my_kid, then remove the old key after token TTL.
E) JWT client assertion checks (why invalid_client happens)
When exchanging the auth code (or for backend services), ensure:
iss = your client_id, sub = client_id
aud = token endpoint URL you’re POSTing to
exp ≤ 5 minutes after iat
kid header matches a JWK at your registered JWKS URL
Expect up to ~60 minutes for Sandbox to see new keys.