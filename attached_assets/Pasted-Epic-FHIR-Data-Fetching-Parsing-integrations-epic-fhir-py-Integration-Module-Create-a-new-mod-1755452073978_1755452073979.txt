Epic FHIR Data Fetching & Parsing (integrations/epic_fhir.py)
* Integration Module: Create a new module like integrations/epic_fhir.py (if not already present) to encapsulate FHIR API interactions. This keeps the logic of calling Epic’s FHIR endpoints separate from view code. Functions in this module will use the stored access tokens to query FHIR resources and return data in a usable format for the application.
* FHIR Client Setup: Within this module, set up a base function to issue API calls. For example, api_get(org, resource_path) that:
    * Reads the org.epic_fhir_url (base URL, e.g., https://api.epic.com/interconnect/fhir) from the Organization.
    * Ensures a valid access token for the organization. If the access token is expired (compare current time with token_expiry), attempt to use the refresh token to get a new access token (make a refresh token request to Epic’s token endpoint). Update the stored token and expiry on success. If refresh fails (e.g., revoked), mark the org as not connected and return an error so that a full re-auth may be needed.
    * Sends a GET request to f"{base_url}/{resource_path}" with the Authorization header Bearer <access_token>. Use requests.get and include Accept: application/fhir+json if required by Epic.
    * If a 401 Unauthorized is returned, treat it as an expired token scenario: perform the refresh flow then retry once. If still failing, propagate the error.
* Data Retrieval Functions: Implement helper functions to fetch specific resource types needed for screening:
    * fetch_patient(org, patient_id): Retrieve a Patient resource by ID. On Epic, this may be via GET /Patient/{id} (if you know the ID from launch context) or a search like GET /Patient?identifier=... if identifying by MRN. In a sandbox EHR launch, you often get the patient ID from context. This function should return patient demographics (name, DOB, etc.) parsed from the FHIR JSON.
    * fetch_observations(org, patient_id): Retrieve key Observation resources for the patient. You might query by category or codes to limit to relevant observations. For example, fetch vital signs: GET /Observation?patient={id}&category=vital-signs. Or fetch specific lab results (HDL, LDL cholesterol) by LOINC codes if needed. Parse the JSON bundle to extract values of interest (e.g., latest blood pressure reading, cholesterol values, height and weight). Organize these in a dictionary or object that the screening engine can easily consume.
    * fetch_conditions(org, patient_id): Get a list of current and past conditions for the patient (GET /Condition?patient={id}&clinical-status=active). Parse to identify chronic conditions like diabetes, hypertension, etc., which might factor into screenings.
    * fetch_procedures(org, patient_id): If the screening logic needs past procedures (surgeries, etc.), query Procedure resources (/Procedure?patient={id}) and extract relevant info (e.g., types of procedures or dates).
    * Similarly, implement any other resource fetchers as required by different screening types (Medication, Immunization, etc., if needed for the app’s purpose).
* FHIR Data Parsing: For each of the above, parse the FHIR JSON into a Python structure. For example, after fetching Observations, iterate through the entry list in the FHIR Bundle response and pick out values:
    * For vital signs, map the FHIR codes to human-friendly names (e.g., systolic blood pressure code -> “systolic BP” value). You can create a small mapping of FHIR LOINC codes to the fields needed by the screening engine.
    * Convert units if necessary (e.g., Epic might return height in cm but screening expects inches, etc.).
    * Ensure to handle missing data (if an expected observation isn’t found, decide how the screening will treat it).
    * The output of these parsing functions could be a combined screening input data structure (like a dict) containing Patient info and key observations. Alternatively, the parsing can be done later in the screening engine; but doing it here keeps FHIR-specific logic isolated.
