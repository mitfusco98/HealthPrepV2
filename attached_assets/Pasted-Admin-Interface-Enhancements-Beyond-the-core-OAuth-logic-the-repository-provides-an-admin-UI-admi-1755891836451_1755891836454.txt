Admin Interface Enhancements
Beyond the core OAuth logic, the repository provides an admin UI (/admin/epic/registration) to guide and inform the setup process:
* Start Authorization: The admin page includes a “Connect to Epic” button (visible once client credentials are saved) that triggers the /fhir/epic-authorize flow. This initiates the Epic login/consent in a new browser window or tab (though currently the anchor doesn’t explicitly have target="_blank", the intention is an external Epic login page). This satisfies the requirement to easily start the OAuth flow from the UI.
* Connection Status Check: The implementation provides an /fhir/epic-status endpoint that returns JSON indicating if the app is “connected” (i.e., has a valid access token), the token’s expiration time, scopes, and patient ID (if the token is patient-scoped). The admin page uses AJAX (checkOAuthStatus()) on load to call this and update the UI with a green “Connected” status or a “Not Connected” message, and whether the token is expired. If connected, it also shows options to Disconnect (which calls the /fhir/epic-disconnect to clear tokens) or, if the token is expired, a Reconnect prompt (which again uses the authorize flow). This dynamic status display is very much in line with providing detailed OAuth status information to the administrator, beyond the basic “configured or not” indicator.
* Callback URL Display: Epic’s registration process requires specifying a redirect URI in the Epic client configuration that exactly matches the app’s callback. The admin interface doesn’t explicitly print the URL in text, but it’s implicitly clear that the callback will be .../fhir/epic-callback (since the Connect button ultimately lands the user back at that route). For clarity, it might be useful to display this URL to the admin. In practice, the current design expects the admin to know to use the external URL of the /fhir/epic-callback route as the “OAuth Redirect URI” when registering the app in Epic. Since the app constructs redirect_uri via Flask’s url_for(..., _external=True), it will match the deployed host domain. Providing this explicitly on the UI (for copy-paste) would further reduce ambiguity. It’s a minor point, but one easily added to the registration page instructions.
* Connection Testing: The admin page offers a “Test Connection” feature in two forms. First, upon saving credentials, the UI automatically triggers a test (after 1 second) that attempts to hit Epic’s FHIR base URL. Also, a manual Test Connection button triggers an AJAX POST to /fhir/test-epic-connection. This endpoint verifies the configuration by trying to generate a valid auth URL or even performing a minimal FHIR query. In the fhir_routes.py version, it constructs the auth URL and checks it contains “epic.com” as a sanity check. In the more advanced epic_admin_routes.py, a test call actually attempts a real FHIR Patientquery using the stored token to ensure the token and endpoint are truly working. The result of the test is shown to the admin (success or error details). This two-layer status – (1) basic configuration validity and (2) live API call test – matches the description of Connection Test Results vs OAuth Status Results. In effect, the admin can confirm not only that their Client ID/Secret and URL look correct (able to produce an auth link), but also that an authenticated call actually succeeds with the current token.
All these UI touches (connect button, status indicators, test modal) are implemented to make establishing the Epic connection straightforward and transparent. As a result, when visiting the Epic Registration admin page, an administrator can:
* Enter the Epic-provided Client ID, Client Secret, and FHIR base URL (environment selectable).
* Click Save, then Test Connection to verify the credentials are valid (e.g., the auth URL can be generated, indicating the endpoint is reachable).
* Click Connect to Epic to initiate the OAuth flow – this opens Epic’s authorization page for login/consent.
* After completing Epic authorization, be redirected back with tokens; the page will then show “Connected” status and list scopes, etc. (and the admin can confirm the token is not expired).
* If needed, Disconnect to revoke the session (locally).
* See the callback URL (implicitly known as the app’s /fhir/epic-callback) and the required scopes list, which can be cross-referenced during the app registration on Epic’s side.
The above matches the intended features list: starting the auth flow, checking connection status, viewing what to register (scopes/redirect URI), and testing the FHIR endpoint.
Next Steps: User-Facing Launch Considerations
The current implementation is geared toward an administrator establishing the integration at an organization level. Epic’s documentation also covers end-user launch scenarios (e.g. a patient or provider using the app, either via an Epic EHR launch or a standalone app launch). To fully align with Epic’s SMART on FHIR workflow, the repository may need to extend support to user-facing OAuth flows. Key considerations include:
* Patient/Provider App Context: In Epic’s terminology, if the app will be used by patients or providers directly, the OAuth flow might be triggered in those user contexts. For example, a patient might click “Connect My Epic Account” in the app (a standalone launch), or a provider might launch the app from within Epic’s Hyperspace (an EHR launch). The code currently restricts /epic-authorize to admins only. Enabling a user-level OAuth launch would involve removing or altering that restriction (so non-admin authenticated users can authorize) and likely associating tokens with individual users. The data model anticipates this: the EpicCredentials table has a user_id field for storing tokens per user. Implementing this would allow, for instance, each patient user in the app to have their own Epic OAuth tokens on record.
* EHR Embedded Launch Workflow: If the app is launched from an Epic context (via a SMART launch within the EHR), Epic will provide a one-time launch token and an iss (issuer base URL) to the app’s launch URL. The app then must use those to formulate the authorization redirect (including a launch parameter). Support for this flow would require:
    * A new unauthenticated launch endpoint to receive iss and launch params from Epic (and perhaps redirect=...).
    * The app would use iss to identify the Epic base FHIR URL and match it to a known organization configuration (or dynamically configure one), then call the authorize URL with launch=<token> and the appropriate scopes (including any launch/patient or launch/encounter scope if required).
* Currently, the code doesn’t handle the launch parameter or dynamic iss – it assumes the base URL is preconfigured. To comply with Epic’s full SMART launch spec, implementing this would be needed when the app is used in an embedded context. Epic’s documentation outlines this in steps (where the EHR POSTs to the app’s launch URL and the app then redirects to Epic’s authorize). This is a more advanced use-case and may not be necessary if the app is only ever used in standalone mode by users.
* Dynamic Scope Adjustments: Depending on user context, the scopes requested might be adjusted. The implementation currently requests both patient/* and user/* scopes in one go. In practice, if a patient is authorizing, the user/* scopes might not be applicable, and vice versa. Epic may ignore irrelevant scopes or could require separating contexts (Epic sometimes issues an error if an app asks for both a patient-level and user-level scope without the proper context). Testing in the Epic sandbox will be important to ensure this approach is accepted. If not, the app might need to decide scopes based on context (for example, only request patient/... scopes when a patient user is connecting their own record, vs. user/... scopes when an admin/provider is connecting). The code’s structure (passing a scopes list into get_authorization_url) makes it easy to adjust or subset scopes as needed.
* Offline Access & Long-Term Use: For end-user launched tokens, the offline_access scope (as noted earlier) becomes critical – it allows the app to refresh tokens and access data when the user isn’t actively online. The admin integration likely uses refresh tokens already (the sandbox might issue a refresh without the explicit scope in some cases), but production may enforce requiring that scope. Ensuring that is part of the registered scopes will make the user experience smoother (so they won’t need to reauthorize frequently).
* Security and Session Management: Epic’s guidelines emphasize never exposing access tokens to the front-end and keeping them on the server. The current approach adheres to this by using Flask server-side session and the database for token storage. For a user-facing launch, the app should continue this practice: after the user authorizes with Epic and the callback returns, the app should associate the token with the server-side user session or DB record, and use it server-side for API calls. Any UI indicating “linked to Epic” for the user would just be reflecting the presence of a valid token in the database, not sending the token to the browser.
Given the repository’s solid foundation, extending it to user-facing OAuth launches would involve relatively small additions: adjusting route access control, possibly creating a separate launch entry-point if supporting in-EHR app launch, and testing scope combinations. The structure (with FHIRClient and token refresh logic, and the data models for per-user tokens) is already in place to support these scenarios.