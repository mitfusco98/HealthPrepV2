Epic JWK URL Validation Errors and Causes
When registering your app on Epic’s FHIR sandbox, you encountered errors like “502 Bad Gateway”, “503 Service Unavailable”, and a message “The JWK Set URL could not be validated at this time.” These errors indicate that Epic could not reach your JSON Web Key Set (JWKS) URL when attempting validation. Epic’s documentation explicitly states that JWKS endpoints must: (1) use TLS (HTTPS), (2) be publicly accessible, (3) not require any auth, (4) have stable URLs, and (5) respond reliably. Epic automatically checks points 1–3 as soon as you provide a JWKS URL. In your case, the JWKS URLs were correct but not reachable – for example, if your Replit server was not running or was sleeping, Epic’s real-time check would fail. This led to the 502/503 errors, as Epic’s server couldn’t get a response. To resolve this, ensure your JWKS endpoints are live and accessible on the internet whenever you submit or update the app registration. In practice, this means keeping your server running (Replit instances may shut down when idle) or hosting the JWKS JSON on a stable URL. Epic will treat the JWKS URL as a critical part of your app’s registration: if it can’t fetch your keys, it won’t approve the app. In short, make sure the JWKS URL is up(publicly reachable HTTPS endpoint with no auth) during the validation process. If it wasn’t, the error is expected. After fixing the accessibility, you may need to re-attempt validation and be patient – the sandbox might take some time (up to ~1 hour) to re-check and mark your app as approved. (Epic notes that changes like new keys or URLs can take up to 60 minutes to sync on the sandbox.)
SMART on FHIR Integration Implementation Status
Good news: your project has a full SMART on FHIR (OAuth 2.0) authorization implementation, which appears correctly set up for Epic’s sandbox. The relevant components in the repository include:
* emr/fhir_client.py – a FHIR client class that manages the OAuth 2.0 flow (auth URL generation, token exchange, etc.). It is configured to use Epic’s R4 FHIR base URL and endpoints by default, and it defines the required scopes. For example, the client’s default scope list includes openid, fhirUser, and the necessary patient- and user-level read scopes (e.g. patient/Patient.read, patient/Observation.read, user/Patient.read, etc.). This matches the Epic sandbox’s expectations for a SMART app (you listed patient/*.read, user/*.read, openid, fhirUser, which are all present in the code).
* routes/oauth_routes.py – defines the OAuth endpoints for your app’s front-end. Notably, you have an /oauth/epic-authorize route to initiate the authorization (redirect to Epic’s login/authorize page), and an /oauth/epic-callback route to handle Epic’s redirect back to your app with the authorization code. The code in these routes handles storing a random state for security, redirecting the user, and upon return, validates the state and exchanges the code for tokens. You also implemented /oauth/epic-status(to report the connection status in JSON) and even debug/test endpoints (like /oauth/epic-callback-test and /oauth/epic-authorize-debug) to help during development.
* Test Suite – The file test_smart_on_fhir.py contains tests that simulate the OAuth flow. It confirms that the client generates a proper authorization URL with all required parameters (response_type, client_id, redirect_uri, scope, aud, state) and that the endpoints are configured correctly. It also checks that token handling (including refresh token logic) and HTTP headers for FHIR API calls are implemented (e.g. setting Authorization: Bearer <token> and appropriate Accept headers).
Key features implemented: Your code uses Epic’s OAuth 2.0 Authorization Code grant (with PKCE implicit via the sandbox) for SMART on FHIR. It is pointed at Epic’s current sandbox endpoints – e.g. https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4/ as the FHIR base, with the corresponding authorize and token endpoints derived from that (which are exactly as expected by Epic R4). The scopes mentioned above ensure access to patient data and OpenID Connect info (Epic’s sandbox issues a FHIR user ID and possibly patient context in an ID token if requested). The implementation correctly maintains OAuth state, uses a secure redirect URI, and handles storing the obtained access token (and refresh token, if provided) for your organization’s context.
It’s also worth noting that your code includes support for JWT client assertions for Epic (the “backend services”authentication method). For example, there’s logic to generate a signed JWT (client_assertion) using your private key in jwt_utils.py and epic_public_routes.py (functions like create_client_assertion in your code construct a JWT with iss/sub = client ID and aud = Epic token URL, then sign it with the RSA private key). This is ready to support private_key_jwt authentication if needed. In practice, right now your token exchange is using the client’s secret for simplicity, but you have all the pieces to switch to the asymmetric client assertion method that Epic allows. Overall, your SMART on FHIR integration is complete and correctly configured – the code covers the full OAuth flow (authorize, token, refresh) and aligns with Epic’s sandbox requirements.
JWK Set URL Endpoints and Format
Your application provides two JWKS endpoints for Epic to retrieve your public keys, which is exactly what Epic’s App Orchard expects for backend-auth enabled apps. The endpoints (as configured in your app’s routes) are:
* Non-Production JWKS URL: https://<your-app-domain>/nonprod/.well-known/jwks.json – this is the URL you supply for Epic’s sandbox (non-production) keyGitHub. In your case, it was something like https://55ab1b06-...riker.replit.dev/nonprod/.well-known/jwks.json (the Replit URL).
* Production JWKS URL: https://<your-app-domain>/.well-known/jwks.json – similarly, for actual production client deployments (not the sandbox). You likely provided the non-prod one for now (since you’re integrating with the sandbox).
In the code (routes/epic_public_routes.py), the nonprod_jwks() and prod_jwks() handlers collect the RSA public keys and return them as a JSON Web Key Set. The implementation looks for environment variables holding your PEM-encoded keys and converts them to JWKS format on the fly. If no key is set in the environment (for example, in a dev setup), it even generates a fallback RSA key pair so that the endpoint always returns something. This means the JWKS JSON served by those URLs is properly structured. Each key entry in the JSON contains:
* kty (Key Type) set to "RSA" (Epic accepts RSA keys).
* use set to "sig" indicating the key is for signing (JWT signature verification).
* kid (Key ID) which is a unique identifier for the key. Your code derives this from the environment variable name or uses a default like "nonprod-fallback" if generated. Epic recommends including a kid for each key – this helps them pick the correct key if you rotate keys. Your implementation does supply a kid for each key, which is good.
* The RSA public key components n (modulus) and e (exponent), base64url-encoded. These are critical for Epic to reconstruct your public key and verify JWTs. Your JWKS output includes both n and e for each key.
* alg indicating the algorithm. In code, you’ve set this to "RS256" (RSA using SHA-256). Epic’s system supports RS256 and RS384 for JWTs – and actually notes that RS384 is preferred for new apps. Using RS256 is still perfectly acceptable (and widely used); just be aware Epic allows RS384 too. The main point is the alg in your JWKS should match the algorithm you use to sign the JWT. Since your JWTs (client assertions) are being signed with RS256, having "alg": "RS256" in the JWK is consistent and correct.
The content your JWKS endpoints return therefore meets Epic’s requirements. Epic’s documentation explicitly mentions that backend apps must use a JWKS URL (instead of uploading static certs) once the feature is enforced (it’s optional for now, but required in upcoming Epic versions). You’re ahead of the game by implementing this. Each key in the JWKS is exactly in the format Epic expects (the doc even provides example JSON with similar fields) – for example, an Epic doc snippet shows "kty": "RSA", "n": "...", "e": "...", "alg": "RS384", "kid": "<some ID>", which aligns with what your app serves (aside from using RS256).
One thing to ensure is that your JWKS URL is stable and consistent. Epic warns that the URL should not change over time – since you’re using a .well-known path on a fixed domain, that’s fine. Also, Epic caches the keys from your JWKS for up to 29 hours by default. Your endpoints set a Cache-Control: public, max-age=86400(24 hours) header on the JWKS response, which is good for performance. During development, if you need Epic to fetch the latest keys more frequently (for example, if you rotated a key or the Replit URL changed), you could temporarily set Cache-Control: no-store to force no caching. But generally, the current cache policy is fine. The main takeaway is that the JWKS endpoints and JSON format are correctly implemented in your project – the remaining task is to ensure Epic can reach those URLs (as discussed in section 1). Once it can, Epic will validate that the JWKS is valid JSON and contains at least one key, which your implementation satisfies.
Additional OAuth2 & Epic Sandbox Considerations
Finally, here are some extra troubleshooting tips and confirmations related to OAuth 2.0 and calling the Epic sandbox APIs, to ensure everything works smoothly:
* App Orchard Settings: Double-check your app’s configuration on the Epic on FHIR (App Orchard) site. Since you are using JWT authentication, your app should be marked with the “Backend Systems” user type (if it’s a backend service) and the “OAuth 2.0” option enabled. (On the Epic on FHIR site, the OAuth 2.0 checkbox is usually pre-selected for modern apps.) If your app also does user-facing launches, ensure the appropriate user types are selected. Additionally, if you want to use refresh tokens, make sure “Require Refresh Tokens” is checked in your app configuration – this is required in order to upload a public key for JWT apps in certain cases.
* Public Key Registration: It sounds like you supplied the JWKS URL instead of uploading a static key/certificate (which is good). Just be aware that the Epic sandbox has separate fields for Sandbox Public Key / JWKS URLand for client-specific keys when you go live with customers. Since you’re using the JWKS URL, you don’t need to manually upload a key for the sandbox – the URL is your source of truth. Do ensure that the private key you use to sign your JWT (for client assertions) matches the public key served in the JWKS. This sounds obvious, but it’s worth verifying (especially if you ever update the key). If you ever change the key or JWKS content, remember Epic notes that it can take up to 60 minutes for the sandbox to recognize the new key (and up to 12 hours on a real production client system). In other words, if you update your JWKS or re-upload a key, give the system some time before testing again.
* OAuth Token Requests: Your implementation already handles the token request, but as a sanity check, recall the requirements for the OAuth token exchange:
    * The request must be a POST to the /oauth2/token endpoint (not /authorize).
    * The POST body must use content type application/x-www-form-urlencoded and contain all the required fields (grant_type, code, redirect_uri, etc.). Your FHIRClient.exchange_code_for_token()method does send a form-encoded POST with those fields, which is correct.
    * If using client credentials or JWT assertions, ensure the parameters are exactly correct: Epic’s docs emphasize using client_assertion (no extra dash) and the specific client_assertion_type value if you go that route. In your code, currently you send client_id and client_secret in the token request (standard authorization_code flow with a confidential client). That’s fine for now. If you decide to switch to the private key JWT method (to fully eliminate the client secret), you would instead include client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer and client_assertion=<your signed JWT> in the token POST. Epic supports this method – the sandbox’s OpenID configuration explicitly lists private_key_jwt as a supported token auth method. Your code already has the ability to generate the assertion JWT, so it would just be a matter of adjusting the token request to use it. This can be done later; it’s an enhancement rather than a blocker for sandbox approval.
* Making FHIR API Calls: Once you have an access token from Epic, your app can call the FHIR REST endpoints in the sandbox. Ensure each API call includes the token in the header and proper headers: e.g. Authorization: Bearer <access_token>, Accept: application/fhir+json, and Content-Type: application/fhir+json (for writes) or as required. Your test code confirms that the client sets these headers correctly for requests. The Epic sandbox base URL you’re using (https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4/) will allow you to query sample data. For example, you might call GET .../Patient/{id} or other resource endpoints. Given the scopes you requested (like patient/Patient.read, etc.), you’ll be able to read data for the patient context that the token is tied to. If you performed a launch in the sandbox, Epic typically provides a patient in context (or you may use an open patient context in sandbox testing). If you encounter issues with no data, ensure you have the correct patient ID (the token’s patient claim or context, which your code stores as epic_creds.patient_idGitHub) and that you’re using the right resource types that match your scopes.
* Waiting for Approval: As a final note, it’s normal for the Epic App Orchard sandbox to take a little time after you register or update your app before everything works. You mentioned waiting about an hour – this is expected. After you submitted the JWKS URL and any other required info, Epic’s backend does some verification and then marks the app as “approved” for sandbox use. During this period (up to ~60 minutes), attempts to authorize might fail or the app may not appear active. This is the “1-hour approval wait” you noted. If your JWKS URL was unreachable initially, you may need to re-trigger validation (for example, by editing and re-saving the app configuration on the website) once your server is up. Then give it some time. As long as the URL is accessible and returns the proper JWKS, the app should eventually be approved in the sandbox. You can monitor the Epic on FHIR portal for status changes.
