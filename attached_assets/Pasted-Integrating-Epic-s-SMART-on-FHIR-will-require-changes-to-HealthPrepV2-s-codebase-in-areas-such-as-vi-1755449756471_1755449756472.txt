Integrating Epic’s SMART on FHIR will require changes to HealthPrepV2’s codebase in areas such as views (controllers), models, and how the app makes API calls. Below are suggested architectural changes and enhancements:
* OAuth2 Authorization Flow (Views/Controllers): Implement new views or endpoints to handle the SMART launch sequence:
    * A “Connect to Epic” trigger – for example, a button that a user (admin or provider) clicks in HealthPrepV2 to initiate the Epic login. This would redirect the user to the Epic authorization URL (as constructed in the previous section). This could be a simple view that uses the Client ID, scopes, etc., to build the URL and then issues an HTTP redirect.
    * An OAuth Callback endpoint – this is the redirect URI that Epic will call with the authorization code. In a Django app, for instance, you’d add a view like /oauth/callback/ that extracts request.GET['code'] and state, verifies the state for security, then performs the token exchange. This view will likely use a server-side HTTP client (e.g., Python’s requests library) to POST to Epic’s token endpoint. Upon success, it should save the tokens (access_token and refresh_token). You might store them in the user’s session or a database model linked to the user. Given this is a multi-tenant app (multiple clinics), you’ll also need to associate tokens with the correct user and organization.
    * Token Refresh logic – Since tokens expire, incorporate logic to refresh tokens when needed. This could be a background task or checked on each API call. If an API call returns 401 Unauthorized (token expired), the app should use the stored refresh token to get a new access token (and update the stored credentials). Ensuring a smooth token refresh will help maintain the “real-time EMR sync” without requiring users to constantly log in.
* FHIR API Client (Service Layer): Create a module or service class to abstract FHIR API calls. Rather than scattering raw HTTP calls across the code, a dedicated FHIR client component can handle GET/POST requests, token management, and error handling. For example, a class EpicFHIRClient could be initialized with the base URL and an access token. It could have methods like get_patient(id), search_conditions(patient_id), post_documentreference(data) which internally format the requests to the correct endpoints (perhaps using a library or just forming URLs). There are libraries available (e.g., the SMART on FHIR client libraries for Python and JavaScript) that can help manage FHIR resources, but a lightweight approach using requests or fetch (in JS) can suffice. The Topology Health example demonstrates using a SMART client object to create a DocumentReference; in HealthPrepV2, the implementation might be server-side, so a custom approach with requests in Python or an official FHIR client library (like fhirclient for Python) could be used to simplify handling resource objects.
* Models and Data Handling: Review how HealthPrepV2 stores and processes patient data and documents:
    * If the app currently uses internal models for Patient, Document, etc., you might integrate those with FHIR IDs. For instance, when a patient is fetched from Epic, you could store a record in your database linking the local patient entry to the Epic Patient.id. This can expedite future queries (so you know which Epic patient corresponds to which local record). However, be cautious about duplicating PHI – you might decide not to store patient demographics locally at all, and instead fetch them on demand via FHIR (which is feasible with fast queries and if the data doesn’t need heavy manipulation). This aligns with not storing more PHI than necessary in the app’s database.
    * Document management: Instead of uploading documents manually to HealthPrepV2, the integration now pulls documents from Epic. The screening engine’s document parser should accept input from the FHIR DocumentReference results. For example, for each DocumentReference, if an attachment.data (base64 PDF) is present, the app can decode it and feed it to the OCR/keyword matcher. If only a URL is given (which might require an authenticated download via Epic’s Binary resource), the FHIR client should handle fetching that as well (the Epic sandbox may provide direct URLs for certain test files, or require a second API call to Binary/{id} with the same token to get the content).
    * Writing results: When writing back a prep sheet, you might create a model to log that a DocumentReference was created (store the Epic DocumentReference ID and date). This can be used to avoid duplicate submissions and to provide a link in the app if needed to view the prep sheet. However, the source of truth will be Epic, so storing the entire content may be unnecessary. If the app wants to allow users to download the prep sheet from its UI as well, storing a copy (or regenerating on the fly) might be considered. Given HIPAA concerns, if you store the prep sheet content, treat it as PHI and encrypt it at rest.